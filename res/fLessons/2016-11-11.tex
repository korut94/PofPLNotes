\section{Lezione 2016-11-11}
\subsection{TODO}
% Insert what you need. Any row is associated with the improvment or mistake
% arise. In the first column you can insert what you should resolve or change,
% instead in the second column you may put the section where to apply some
% modification.
\begin{table}[H]
\begin{center}
\begin{tabular}{|p{\textwidth}|c|}
\hline
\multicolumn{1}{|c|}{\textbf{Miglioramento}} & \textbf{Sezione} \\ \hline
\end{tabular}
\end{center}
\caption{Tabella miglioramenti}
\label{tab:tab_todo}
\end{table}

\subsection{Liveness/Next-Use}
Trought a graph we can keep track of the variable's life. Instead keep the
information in a single block (scope), we can find the life for the whole
program. Also, we keep the local life information into the nodes.

\subsection{Dataflow analysis}
Many static analyses are dataflow analysis:
\begin{itemize}
\item Livenss
\end{itemize}

Step:
\begin{enumerate}
\item Determine the leaders: fist statement, each targer of the goto. So there
are the first istruction of the block and the immediatly next
\item Take the block and plug each leaders
\end{enumerate}

How many registers do I need to compile this program?
we considere $v$ live at a point of the program so there is a path from $v$
an another program $p$ where $v$ is used.

In this way we can calculate when a variable alive. In the control flow graph
attach in the edges the set of alive variables.

\subsection{Determining Live Sets}
The approch of the data flow analysis:
\begin{itemize}
\item consider the origin of information, where liveness holds because of immediate
observation
\item the propagation of informazion
\item joining information: how liveness info is passed acrosss the boundaries
of the block
\end{itemize}

\subsubsection{Orign information}
If a variable is used at a program point p, then it must be alvie immediately
before p.

If the variable is not used before p, we must see the propagatation:
\begin{enumerate}
\item it is alive immediate after p
\item it is not refefined at p
\end{enumerate}

Le espressioni very busy si intendo quando viene calcolata in ogni path da un
certo punto del programma fino alla sua terminazione.

La propagazione e' very bysu se e' immediatamente very busy prima di p e le
variabili

\subsection{Reaching definitions}
La reaching definition e' molto utile per varie tecninche di ottimizzazione in
combinazione con altre tecniche.

Un'assegnazione e' morta perche' la definizione della variabile non raggiunge
nessun uso di quella variabile. Noi abbiamo definito una variabile ma non viene
piu' usata.

\subsubsection{Information origin}
Se un programma da un punto p defini una variabile v allora v e' ustata
immediatamente dopo p.
\subsubsection{Propagation}
v raggiunge p sse:
\begin{enumerate}
\item la definition raggiunghte il punto immediatamente prima di p.
\item la v non e' ridefinita a p
\end{enumerate}
\subsubsection{joinin}
v raggiiunge immediatamente dopo almeno un predecessore di p se lui raggiunge
il punto immediatamente prima di p.
\subsubsection{IN - OUT}
IN = isieme di deinition che raggiunge il punto imediatamente prima di p
OUT = insieme di definition che faggiunto il punto immediamente dopo p.
\subsubsection{Equation}
\begin{align*}
  IN(p) &= \bigcup OUT(p_s),p_s \in pred(p) \\
  OUT(p) &= (IN(p) \over \{defs(v))\} \cup \{p\}
\end{align*}

\subsection{Transfer functions}
Le liveness e very busy expression sono \textbf{backward} dataf low analysis
perche' guardano l'operazione precedente
$$IN[s] = f_s(OUT[s])$$
le altre due sono \textbf{forward} data flow analysis
$$OUT[s] = f_s(IN[s])$$

Le transfer functions sono quelle sono il simbolo d'unione e l'intersezione.

La mergin function definisce il comportamente della collisione di piu' punti.



\subsection{Nota generale}
Per ogni definizione basta guardare: l'origine dell'informazione, propagazione
e la join. Da li si calcola l'IN e l'OUT per fare data-flow analysis.
